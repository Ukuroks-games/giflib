-- Services

local ContentProvider = game:GetService("ContentProvider")

-- Libraries

local algorithm = require(script.Parent.Parent.stdlib).algorithm

local gifFrame = require(script.Parent.gifFrame)

--[[
	# Library for creating gif
]]
local gif = {}

--[[
	Gif mode
]]
gif.Mode = {
	Replace = 0,
	Combine = 1,
}

export type GifStruct = {
	--[[
		List of gif frames

		[wiki](https://github.com/Ukuroks-games/giflib/wiki/Gif#frames--gifframegifframe-)
	]]
	Frames: { gifFrame.GifFrame },

	--[[
		Gif surface

		[wiki](https://github.com/Ukuroks-games/giflib/wiki/Gif#parent-guibase)
	]]
	Parent: GuiBase?,

	--[[
		Current frame num

		[wiki](https://github.com/Ukuroks-games/giflib/wiki/Gif#frame-number)
	]]
	Frame: number,

	--[[
		Анимация сейчас запущенна

		[wiki](https://github.com/Ukuroks-games/giflib/wiki/Gif#animationrunning-boolean)
	]]
	AnimationRunning: boolean,

	--[[
		Gif is looped

		if true animation is will be looped.

		[wiki](https://github.com/Ukuroks-games/giflib/wiki/Gif#loopanimation-boolean)
	]]
	LoopAnimation: boolean,

	--[[
		Images are preloaded

		[wiki](
	]]
	IsLoaded: boolean,

	--[[
		Fire where gif animation completed

		[wiki](
	]]
	Completed: RBXScriptSignal,

	--[[
		Fire where gif animation completed

		[wiki](
	]]
	CompletedEvent: BindableEvent,

	--[[
		Fire if gif destroying(Destroy called)

		[wiki](
	]]
	Destroying: RBXScriptConnection,

	--[[
		Fire where Destroy call

		[wiki](
	]]
	DestroyingEvent: BindableEvent,

	--[[
		Thread int that gif animation running

		[wiki](
	]]
	AnimationThread: thread,

	--[[
		Gif mode. See gif.Mode

		[wiki](https://github.com/Ukuroks-games/giflib/wiki/Gif#mode-number)
	]]
	Mode: number,
}

--[[
	Gif struct
]]
export type Gif = typeof(setmetatable({} :: GifStruct, {__index = gif}))

--[[
	Destroy gif

	[wiki](
]]
function gif.Destroy(self: Gif, notDestroyFrames: boolean?)
	self.DestroyingEvent:Fire()

	-- Если анимация всё ещё запущенна
	gif.StopAnimation(self)

	if not notDestroyFrames then
		-- Destroy frames
		for _, v in pairs(self.Frames) do
			if v then
				gifFrame.Destroy(v)
			end
		end
	end

	self.CompletedEvent:Destroy()
	self.DestroyingEvent:Destroy()

	table.clear(self)
end

--[[
	Wait all image loading

	[wiki](
]]
function gif.Preload(self: Gif, skip: number? | boolean?)
	ContentProvider:PreloadAsync(
		algorithm.copy_by_prop(self.Frames, "Image.Image"),
		function(assetId: string, assetFetchStatus: Enum.AssetFetchStatus)
			if assetFetchStatus == Enum.AssetFetchStatus.TimedOut or assetFetchStatus == Enum.AssetFetchStatus.Failure then
				print(assetFetchStatus)
				warn(tostring(assetFetchStatus) .. " to load " .. assetId)
			end
		end
	)

	if
		(typeof(skip) == "boolean" and skip ~= true)
		or (typeof(skip) == "number")
	then
		local delay = (function()
			if typeof(skip) == "number" then
				return skip
			else
				return 20
			end
		end)()
		for _, v in pairs(self.Frames) do
			gifFrame.WaitLoading(v, delay / #self.Frames)
		end
	end

	self.IsLoaded = true
end

--[[
	[wiki](
]]
function gif.AnimationLoop(self: Gif)
	while
		(#self.Frames > self.Frame)
		and (#self.Frames ~= 0)
		and (self.AnimationRunning == true)
	do
		local time = os.clock()

		gif.Next(self)

		local t = self.Frames[self.Frame].Time - (os.clock() - time)

		if t > 0 then
			task.wait(t)
		end
	end

	self.AnimationRunning = false

	self.CompletedEvent:Fire()
end

--[[
	Start gif animation

	[wiki](
]]
function gif.StartAnimation(self: Gif, skip: number? | boolean?)
	if self.AnimationRunning ~= true then
		self.AnimationRunning = true

		if not self.IsLoaded then -- preload gif if it not been preloaded before
			gif.Preload(self, skip)
		end

		self.AnimationThread = task.spawn(gif.AnimationLoop, self)
	else
		warn("Animation already running")
	end
end

--[[
	Stop gif animation

	[wiki](
]]
function gif.StopAnimation(self: Gif)
	if self.AnimationRunning and self.AnimationThread then
		task.cancel(self.AnimationThread)
		self.AnimationThread = nil
	elseif self.AnimationRunning then
		warn("StartAnimation not been done")
	else
		warn("Animation", self, "not been started yet")
	end

	self.AnimationRunning = false
end

--[[
	Set current frame, that showing now

	[wiki](
]]
function gif.SetFrame(self: Gif, frame: number)
	if self.Parent and self.Frames[frame] then
		gifFrame.Show(self.Frames[frame], self.Parent)

		if self.Frame ~= 0 and self.Mode == gif.Mode.Replace then
			gifFrame.Hide(self.Frames[self.Frame]) -- hide last frame
		end
	else
		warn("Parent or self.Frames[" .. frame .. "] not exist")
	end

	self.Frame = frame
end

--[[
	Reset animation.

	[wiki](
]]
function gif.ResetAnimation(self: Gif)
	self.Frame = 0

	if self.Mode == gif.Mode.Combine then
		gif.Hide(self)
	end
end

--[[
	Restart animation

	[wiki](
]]
function gif.RestartAnimation(self: Gif, skip: number? | boolean?)
	gif.ResetAnimation(self)
	gif.StartAnimation(self, skip)
end

--[[
	Next frame

	[wiki](
]]
function gif.Next(self: Gif)
	gif.SetFrame(self, self.Frame + 1)
end

--[[
	Hide gif frames

	[wiki](
]]
function gif.Hide(self: Gif)
	for _, v in pairs(self.Frames) do
		gifFrame.Hide(v)
	end
end

--[[
	Set frames background transparency

	[wiki](
]]
function gif.SetBackgroundTransparency(self: Gif, newTransparency: number)
	if self.Mode == gif.Mode.Combine then
		self.Frames[1].Image.BackgroundTransparency = newTransparency
	elseif self.Mode == gif.Mode.Replace then
		for _, v in pairs(self.Frames) do
			v.Image.BackgroundTransparency = newTransparency
		end
	else
		warn("unknown mode" .. tostring(self.Mode))
	end
end

--[[
	Set frames background color

	[wiki](
]]
function gif.SetBackgroundColor(self: Gif, newColor: Color3)
	for _, v in pairs(self.Frames) do
		v.Image.BackgroundColor3 = newColor
	end
end

--[[
	Set images transparency

	not working normally with combine mode

	[wiki](
]]
function gif.SetTransparency(self: Gif, newTransparency: number)
	for _, v in pairs(self.Frames) do
		v.Image.ImageTransparency = newTransparency
	end
end

--[[
	Set scale type

	[wiki](
]]
function gif.SetScaleType(self: Gif, scaleType: Enum.ScaleType)
	for _, v in pairs(self.Frames) do
		v.Image.ScaleType = scaleType
	end
end

--[[
	Set resample mode

	[wiki](
]]
function gif.SetResampleMode(self: Gif, resampleMode: Enum.ResamplerMode)
	for _, v in pairs(self.Frames) do
		v.Image.ResampleMode = resampleMode
	end
end

--[[
	Set gif parent

	[wiki](
]]
function gif.SetParent(self: Gif, newParent: Frame?)
	self.Parent = newParent
	self.Frames[self.Frame].Image.Parent = newParent
end

--[[
	Get total animation time

	[wiki](
]]
function gif.GetTotalAnimationTime(self: Gif): number
	return algorithm.accumulate_by_prop(self.Frames, "Time")
end

--[[
	Add frame

	[wiki](
]]
function gif.AddFrame(self: Gif, frame: gifFrame.GifFrame)
	self.IsLoaded = self.IsLoaded and frame.Image.IsLoaded
	table.insert(self.Frames, frame)
end

--[[
	Gif constructor

	`frames` - list of `GifFrame`s

	`parent` - gif surface. Parent for all frames

	`loopAnimation` - if true animation is will be looped

	`ShowFirstFrameBeforeLoading` - Show the first frame before animation start

	[wiki](
]]
function gif.new(
	frames: { [number]: gifFrame.GifFrame }?,
	parent: Frame?,
	loopAnimation: boolean?,
	ShowFirstFrameBeforeStart: boolean?,
	mode: number?
): Gif
	local _CompletedEvent = Instance.new("BindableEvent")
	local _DestroyingEvent = Instance.new("BindableEvent")

	local self: GifStruct = {
		Parent = parent,
		Frames = frames or {},
		Frame = 0,
		AnimationRunning = false,
		Completed = _CompletedEvent.Event,
		CompletedEvent = _CompletedEvent,
		Destroying = _DestroyingEvent.Event,
		DestroyingEvent = _DestroyingEvent,
		LoopAnimation = loopAnimation or false,
		IsLoaded = false,
		AnimationThread = nil,
		Mode = mode or gif.Mode.Replace,
	}

	setmetatable(self, { __index = gif })

	gif.Hide(self)

	if ShowFirstFrameBeforeStart == true then
		if parent ~= nil then
			gif.Next(self)
		else
			warn("gif parent is nil. So how show first frame?")
		end
	end

	if mode == gif.Mode.Combine then
		for i = 2, #self.Frames do
			self.Frames[i].Image.BackgroundTransparency = 1
		end
	end

	self.Completed:Connect(function()
		if self.LoopAnimation then
			gif.RestartAnimation(self)
		else
			gif.StopAnimation(self)
		end
	end)

	return self
end

return gif
